#### 组件封装原则

#### 1. render内使用箭头函数或者bind函数，可能会造成子组件额外的重新渲染。

```javascript
class LoggingButton extends React.Component {
  handleClick() {
    console.log('this is:', this);
  }

  render() {
    // 此语法确保 `handleClick` 内的 `this` 已被绑定。
    return (
      <button onClick={() => this.handleClick()}>
      // onClick={this.handleClick.bind(this)}实际上也会造成性能浪费
        Click me
      </button>
    );
  }
}
```

每次渲染 LoggingButton 时都会创建不同的回调函数。在大多数情况下，这没什么问题，但如果该回调函数作为 prop 传入子组件时，这些组件可能会进行额外的重新渲染。我们通常建议在构造器中绑定或使用 class fields 语法来避免这类性能问题。

#### 2. React 渲染

##### 为什么有必要设置key? 要讲一下React的Diffing算法

React 的 render() 方法，会创建一棵由 React 元素组成的树。在下一次 state 或 props 更新时，相同的 render() 方法会返回一棵不同的树。React 需要基于这两棵树之间的差别来判断如何有效率的更新 UI 以保证当前 UI 与最新的树保持同步。

React 在以下两个假设的基础之上提出了一套 O(n) 的启发式算法来生成将一棵树转换成另一棵树的最小操作数。
1. 两个不同类型的元素会产生出不同的树；
2. 开发者可以通过 key prop 来暗示哪些子元素在不同的渲染下能保持稳定；

**Diffing 算法**
当对比两颗树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。

1. 对比不同类型的元素
  当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。
  当拆卸一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmount() 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 componentWillMount() 方法，紧接着 componentDidMount() 方法。所有跟之前的树所关联的 state 也会被销毁。
  在根节点以下的组件也会被卸载，它们的状态会被销毁。
2. 对比同一类型的元素
  当对比两个相同类型的 React 元素时，React 会保留 DOM 节点，仅比对及更新有改变的属性。
  在处理完当前节点之后，React 继续对子节点进行递归。
3. 对比同类型的组件元素
  当一个组件更新时，组件实例保持不变，这样 state 在跨越不同的渲染时保持一致。React 将更新该组件实例的 props 以跟最新的元素保持一致，并且调用该实例的 componentWillReceiveProps() 和 componentWillUpdate() 方法。
4. 对子节点进行递归
  默认条件下，当递归 DOM 节点的子元素时，React 会同时遍历两个子元素的列表；当产生差异时，生成一个 mutation。
  在子元素列表末尾新增元素时，更新开销比较小。
  如果只是简单的将新增元素插入到表头，那么更新开销会比较大。React会重建每一个子元素 。这种情况会带来性能问题。
  **为了解决以上问题，React 支持 key 属性。当子元素拥有 key(这个 key 不需要全局唯一，但在列表中需要保持唯一。) 时，React 使用 key 来匹配原有树上的子元素以及最新树上的子元素。**

如果没有对渲染项设置key,会默认设置其index为key,不过如果列表项目的顺序可能会变化，不建议使用索引来用作 key 值。因为这样做会导致性能变差（**key 来决定是否更新以及复用**），还可能引起组件状态的问题。原因如下：

Key是React用来识别Dom元素的唯一东西，如果变更元素后的key和之前某元素一样，则React会认为该元素就是之前的元素，这种情况下，它导致非受控组件的 state（比如输入框）可能相互篡改导致无法预期的变动。

React 可以在每个 action 之后对整个应用进行重新渲染，得到的最终结果也会是一样的。在此情境下，重新渲染表示在所有组件内调用 render 方法，这不代表 React 会卸载或装载它们。React 只会基于以上提到的规则来决定如何进行差异的合并。

 React 依赖探索的算法，因此当以下假设没有得到满足，性能会有所损耗。

1. 该算法不会尝试匹配不同组件类型的子树。如果你发现你在两种不同类型的组件中切换，但输出非常相似的内容，建议把它们改成同一类型。

2. Key 应该具有稳定，可预测，以及列表内唯一的特质。不稳定的 key（比如通过 Math.random() 生成的）会导致许多组件实例和 DOM 节点被不必要地重新创建，这可能导致性能下降和子组件中的状态丢失。

#### 3. 受控组件和非受控组件

在React中，所谓受控组件和非受控组件都是针对表单而言的。

表单元素依赖于状态，表单元素需要默认值实时映射到状态的时候，就是受控组件（和双向绑定类似），非受控组件即不受状态的控制，获取数据就是相当于操作DOM。

受控组件的优点是，我们可以实时对输入的内容进行校验，表单的修改也可以实时映射到状态值上。 缺点是我们要为受控组件的每个状态更新都编写数据处理函数，会增加代码量和开发难度。

非受控组件的优点是很容易和第三方组件结合，真实数据都存储在DOM节点中，可以同时集成React和非React代码，快速编写，减少代码量。

同时，也有一些始终是非受控组件的表单元素，比如`<input type="file"/>`

**获取非受控组件的状态，可以使用ref**

#### 4. Context

Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。

Context 主要应用场景在于很多不同层级的组件需要访问同样一些的数据。请谨慎使用，因为这会使得组件的复用性变差。

**如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。**

Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。

##### 5. 错误边界

过去，组件内的 JavaScript 错误会导致 React 的内部状态被破坏，并且在下一次渲染时 产生 可能无法追踪的 错误。

错误边界是一种 React 组件，这种组件可以捕获并打印发生在其子组件树任何位置的 JavaScript 错误，并且，它会渲染出备用 UI，而不是渲染那些崩溃了的子组件树。错误边界在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误。

错误边界无法捕获以下场景中产生的错误：
1. 事件处理
2. 异步代码（例如 setTimeout 或 requestAnimationFrame 回调函数）
3. 服务端渲染
4. 它自身抛出来的错误（并非它的子组件）

**当抛出错误后，请使用 static getDerivedStateFromError() 渲染备用 UI ，使用 componentDidCatch() 打印错误信息。**

错误边界仅可以捕获其子组件的错误，它无法捕获其自身的错误。

#### 6. 高阶组件（HOC）

HOC 不会修改传入的组件，也不会使用继承来复制其行为。相反，HOC 通过将组件包装在容器组件中来组成新组件。HOC 是纯函数，没有副作用。

