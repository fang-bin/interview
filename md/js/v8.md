# V8引擎机制

## V8如何执行一段JS代码

## v8的垃圾回收机制

#### 内存泄漏，内存溢出

**内存泄漏**: 是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

**内存溢出**: 是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于能提供的最大内存。此时程序就运行不了，系统会提示内存溢出，有时候会自动关闭软件，重启电脑或者软件后释放掉一部分内存又可以正常运行该软件，而由系统配置、数据流、用户代码等原因而导致的内存溢出错误，即使用户重新执行任务依然无法避免。

**内存泄露是造成内存溢出的其中一个原因，但是内存泄露不一定会造成内存溢出。**

解决内存泄漏的方法（原因）:

* js在非严格模式下，无意中产生全局变量，应该尽量使用严格模式('use strict')，同时尽量避免使用全局变量，如果使用全局变量存储大量信息，在使用过之后将其指定为null或者重新分配它。
* 定时器完成工作后，要记得手动清除定时器。
* 对dom节点的引用，要及时清除（比如引用了表格中的一个td,由于子元素对父元素是引用关系，代码如果保留了对td的引用，会导致整个表格一直待在内存中）
* 尽量减少闭包（闭包中的一些变量并不会随着上下文被释放掉）

#### 垃圾回收机制

垃圾回收的方式主要有两种: **引用计数**、**标记清除**

**引用计数**：给一个变量赋值引用类型，则该对象的引用次数+1，如果这个变量变成了其他值，那么该对象的引用次数-1，垃圾回收器会回收引用次数为0的对象。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。
**标记清除**：垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。

JS引擎中对变量的存储主要有两种位置，栈内存和堆内存，栈内存存储基本类型数据以及引用类型数据的内存地址，堆内存储存引用类型的数据。

栈内存调用栈上下文切换后就被回收，比较简单。

V8的堆内存分为新生代内存和老生代内存，新生代内存是临时分配的内存，存在时间短，老生代内存存在时间长。

其中新生代内存和老生代内存使用的垃圾回收算法不同。

**新生代内存**中算法将内存均分为二，一块处于使用状态称为From空间，一块处于闲置状态称为To空间。在一轮GC(Garbage Collection 垃圾回收)过程中，会将From空间没有引用的对象释放回收，仍然活跃的对象则会被从From复制到To空间，然后清除From空间的内存，再交换To空间、From空间（此时，活跃对象相当于又置于了From空间，To空间则为空，交换From空间、To空间就是为了让活跃对象都保存在一块内存当中，而另一块内存空闲，由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时间效率上有优异的体现。属于典型的牺牲空间换取时间的算法），下一轮GC开始时，会重复上面的步骤，**如果一个对象是第二次经历从From空间复制到To空间，那么这个对象会被移动到老生代中（这个过程叫做晋升）。**

当要从From空间复制一个对象到To空间时，如果To空间已经使用了超过25%，则这个对象直接晋升到老生代中。设置25%这个阈值的原因是当这次Scavenge回收完成后，这个To空间会变为From空间，接下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。

**老生代内存**中则使用Mark-Sweep(标记清除)和Mark-Compact(标记整理)结合方法。

**Mark-Sweep**在标记阶段遍历堆内存中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。与Scavenge不同，Mark-Sweep并不会将内存分为两份，所以不存在浪费一半空间的行为。

**Mark-Compact**在标记完存活对象以后，会将活着的对象向内存空间的一端移动，移动完成后，直接清理掉边界外的所有内存。

由于Mark-Conpact需要移动对象，所以它的执行速度不可能很快，在取舍上，V8主要使用Mark-Sweep，在空间不足以对从新生代中晋升过来的对象进行分配时，才使用Mark-Compact。

也就是说，Scavenge只复制活着的对象，而Mark-Sweep只清除死了的对象。活对象在新生代中只占较少部分，死对象在老生代中只占较少部分，这就是两种回收方式都能高效处理的原因。

触发GC(垃圾回收):
* 剩余空间不足完成接下来的内存分配
* 定时器，设定一定时间间隔进行清除（各个浏览器时间间隔都不一样）

## V8针对JS的效率优化

编译型语言在程序执行之前,有一个单独的编译过程,将程序翻译成机器语言就不用再进行翻译了。 解释型语言,是在运行的时候将程序翻译成机器语言,所以运行速度相对于编C/C++ 等都是编译型语言,而Java,C#,JavaScript等都是解释型语言。

##### JS的效率问题
* 动态类型: 导致每次存取属性/寻求方法时候，都需要先检查类型；此外动态类型也很难在编译阶段进行优化
* 属性存取: C++/Java等语言中方法、属性是存储在数组中的，仅需数组位移就可以获取，而JS存储在对象中，每次获取都要进行哈希查询

##### V8的优化

* 优化JIT(Just-In-Time 即时编译): 较于C++/Java这类编译型语言，JS一边解释一边执行，效率低。V8对这个过程进行了优化：如果一段代码被执行多次，那么V8会把这段代码转化为机器码缓存下来，下次运行时直接使用机器码。
* 隐藏类: 对于C++这类语言来说，仅需几个指令就能通过偏移量获取变量信息，而JS需要进行字符串匹配，效率低，V8借用了类和偏移位置的思想，将对象划分成不同的组，即隐藏类
* 内嵌缓存: 即缓存对象查询的结果。常规查询过程是：获取隐藏类地址 -> 根据属性名查找偏移值 -> 计算该属性地址，内嵌缓存就是对这一过程结果的缓存
* 垃圾回收管理




