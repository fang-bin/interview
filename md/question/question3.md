1. ts中 public private protected 的区别

* 在TypeScript里，成员都默认为 public。
* 当成员被标记成 private时，它就不能在声明它的类的外部访问。(**在派生类中也不能访问基类的私有属性**)
* protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。

当比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。

2. 作用域链和作用域

作用域其实就是一套规则，这套规则用来管理js如何在当前环境根据标识符进行变量查找。

而作用域链是作用域的具体实现。

作用域链是由当前环境及上层环境一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。

作用域链由一系列变量对象组成，可以当成是由当前执行上下文的变量对象为起点，到全局执行上下文的变量对象为终点的一条单向访问的链式通道。

js是静态作用域，即在函数声明阶段（代码解析阶段）就确定了函数作用域。

不要将执行上下文和作用域链搞混。。。

3. 闭包

闭包可以理解为一个特殊的对象，由两部分组成。执行上下文(代号A)，以及在该执行上下文中创建的函数（代号B）。

当B执行时，如果访问了A中变量对象中的值，那么闭包就会产生。

（在chrome中，以执行上下文A的函数名代指闭包。可以在devtool中查看）

js的自动垃圾回收机制，当一个值在内存中失去引用后，垃圾回收机制会找到它，将其回收，释放内存，而闭包则会阻止这一过程。

通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。

过多的闭包，可能造成许多变量无法回收，造成内存泄漏。

闭包一般用来模块化（es5中，防止变量污染全局环境等），柯里化等。

4. js 可以实现多态么

多态的实际定义：同一个操作作用于不同的对象上，可以产生不同的解释和不同的执行结果。

多态其实主要针对的是强类型的。

对于强类型语言，如C++、C#、Java，通常采用抽象类或接口进行更高一层的抽象，从而可以使用该抽象，本质上是为了**弱化具体类型**

多态最常见的两种实现方式是: 覆盖、重载

而对于 js 这种弱类型语言来说，可以说多态的本身就是与生俱来的，或者说根本不需要这个概念。

覆盖指子类重新定义父类方法，这正好就是基于prototype的继承。

而重载可以通过判断参数来实现。

5. Image.onload事件触发并不取决于返回的状态码

Response 中 Content-Type 是 iamge/xxx 就会触发图片的onload事件,不管返回的状态码是否为404、400等异常状态

6. 虚拟DOM的优缺点

优点: 1. 不直接操作DOM,提升性能 2.跨平台
缺点: 虚拟DOM的构建和diff计算过于复杂的情况下,js比较耗时

7. 无虚拟DOM框架

Svelte 和 SolidJS

这里重点介绍 Svelte 框架

Svelte 是一种全新的构建用户界面的方法。传统框架如 React 和 Vue 在浏览器中需要做大量的工作，而 Svelte 将这些工作放到构建项目的编译阶段来处理。

与使用虚拟（virtual）DOM 差异对比不同。Svelte 编写的代码在应用程序的状态更改时就能有针对性的更新 DOM。

Svelte 的核心思想在于『通过静态编译减少框架运行时的代码量』。举例来说，当前的框架无论是 React Angular 还是 Vue，不管你怎么编译，使用的时候必然需要『引入』框架本身，也就是所谓的运行时 (runtime)。但是用 Svelte 就不一样，一个 Svelte 组件编译了以后，所有需要的运行时代码都包含在里面了，除了引入这个组件本身，你不需要再额外引入一个所谓的框架运行时！

当然，这不是说 Svelte 没有运行时，但是出于两个原因这个代价可以变得很小:

* Svelte 的编译风格是将模板编译为命令式 (imperative) 的原生 DOM 操作。
* 对于特定功能，Svelte 依然有对应的运行时代码，比如组件逻辑，if/else 切换逻辑，循环逻辑等等... 但它在编译时，如果一个功能没用到，对应的代码就根本不会被编译到结果里去。

Svelte 潜在问题:

* 虽然在简单的 demo 里面代码量确实非常小，但同样的组件模板，这样的 imperative 操作生成的代码量会比 vdom 渲染函数要大，多个组件中会有很多重复的代码（虽然 gzip 时候可以缓解，但 parse 和 evaluate 是免不了的）。
* Svelte 在大型应用中的性能还有待观察，尤其是在大量动态内容和嵌套组件的情况下。它的更新策略决定了它也需要类似 React 的 shouldComponentUpdate 的机制来防止过度更新。
另一方面，其性能优势比起现在的主流框架并不是质的区别，现在大部分主流框架的性能都可以做到 vanilla js 的 1.2~1.5 倍慢，基于 Virtual DOM 的 Inferno 更是接近原生，证明了 Virtual DOM 这个方向理论上的可能性，所以可以预见以后 web 的性能瓶颈更多是 DOM 本身而不是框架。
* Svelte 的编译策略决定了它跟 Virtual DOM 绝缘（渲染函数由于其动态性，无法像模板那样可以被可靠地静态分析），也就享受不到 Virtual DOM 带来的诸多好处，比如基于 render function 的组件的强大抽象能力，基于 vdom 做测试，服务端/原生渲染亲和性等等。




