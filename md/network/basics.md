## HTTP

#### HTTP简介
HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。。

HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。

HTTP协议工作于客户端-服务端架构上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。

HTTP默认端口号为80，但是你也可以改为8080或者其他端口。

* **HTTP是无连接** 无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。
* **HTTP是媒体独立的** 这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。
* **HTTP是无状态** HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。


#### HTTP消息结构

**请求消息**
客户端发送一个HTTP请求到服务器的请求消息包括以下格式：请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，下图给出了请求报文的一般格式。

![response](https://github.com/fang-bin/interview/blob/master/image/request.png)

**响应消息**
HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。

![request](https://github.com/fang-bin/interview/blob/master/image/response.jpg)

#### HTTP请求的方法
HTTP/1.0定义了三种请求方法： GET, POST 和 HEAD方法。

HTTP/1.1新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。

| 方法 | 描述 |
| --- | --- |
| GET | 请求指定的页面信息，并返回实体主体。 |
| HEAD | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |
| POST | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |
| PUT | 从客户端向服务器传送的数据取代指定的文档的内容。 |
| DELETE | 请求服务器删除指定的页面。 |
| CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。 |
| OPTIONS | 允许客户端查看服务器的性能。(fetch中都会先发送一个options的预请求) |
| TRACE | 回显服务器收到的请求，主要用于测试或诊断。|
| PATCH | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。 |

**GET**
根据HTTP规范，GET用于信息获取，而且应该是安全的和幂等的。

1. 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。这里安全的含义仅仅是指是非修改信息。

2. 幂等的意味着对同一URL的多个请求应该返回同样的结果。（幂等（idempotent、idempotence）是一个数学或计算机学概念，常见于抽象代数中。最明显的就是绝对值运算 abs(a) === abs(abs(a))）


**POST**
根据HTTP规范，POST表示可能修改变服务器上的资源的请求。

**GET 与 POST的区别**
1. GET请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，参数之间以&相连，POST把提交的数据则放置在是HTTP包的包体中。
2. GET方式提交的数据在某些浏览器上有长度限制（长度限制是浏览器和web服务器决定和设置的，HTTP 协议从未规定 GET/POST 的请求长度限制是多少，例如ie上限制为2083个字节,chrome限制8k，而firefox则实际限制在近100k），不过这个是限制的整个URL的长度，，理论上POST没有限制，可传较大量的数据。（**过长的url会增加服务器的解析时间，因此多数服务器出于安全以及稳定方面的考虑，会给url长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。**）
3. POST的安全性要比GET的安全性高。主要是因为GET的请求的参数明文放在URL上，而且GET请求可以被缓存，同时请求会保留在浏览器历史记录中，GET请求也可以被收藏为书签，而POST都不行

| 方法 | GET | POST |
| --- | --- | --- |
| 后退按钮/刷新 | 没影响 | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）|
| 书签 | 可收藏为书签 | 不可收藏为书签 |
| 缓存 | 可缓存 | 不可缓存 |
| 编码类型 | application/x-www-form-urlencoded | application/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。 |
| 历史记录 | 参数保留在浏览器历史中 | 参数不会保留在浏览器历史中 |
| 对参数数据长度的限制 | 部分受限，由浏览器和web服务器决定 | 	无限制 |
| 对数据类型的限制 | 只允许 ASCII 字符 | 没有限制，也允许二进制数据 |
| 安全性 | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分 | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中 |
| 可见性 | 数据在 URL 中对所有人都是可见的 | 数据不会显示在 URL 中 |

#### HTTP响应头信息

| 响应头 | 说明 |
| --- | --- |
| Allow | 服务器支持哪些请求方法（如GET,POST）|
| Content-Encoding | 文档编码 |
| Content-Length	| 内容长度 |
| Content-Type | 文档属于什么MIME类型。 Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。|
| Date | 当前的GMT时间 |
| Expires	| 文档过期时间，过期之后则不再缓存该文档 |
| Last-Modified | 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。 |
| Location | 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。|
| Refresh | 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader("Refresh", "5; URL=http://host/path")让浏览器读取指定的页面。 | 
| Server | 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。 |
| Set-Cookie | 设置和页面关联的Cookie。Servlet不应使用response.setHeader("Set-Cookie", ...)，而是应使用HttpServletResponse提供的专用方法addCookie。 |
| WWW-Authenticate | 客户应该在Authorization头中提供什么类型的授权信息 |

#### HTTP状态码

| 状态码分类 | 分类说明 |
| --- | --- |
| 1** | 信息，服务器收到请求，需要请求者继续执行操作 |
| 2** | 成功，操作被成功接收并处理 |
| 3** | 重定向，需要进一步的操作以完成请求 |
| 4** | 客户端错误，请求包含语法错误或无法完成请求 |
| 5** | 服务器错误，服务器在处理请求的过程中发生了错误 |

**主要状态码说明**
| 状态码 | 英文描述 | 说明 |
| --- | --- | --- |
| 100 | Continue | 客户端应继续请求 |
| 200 | Ok | 请求成功，一般用于GET和POST请求 |
| 300 | Multiple Choices | 多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择 |
| 301 | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| 302 | Found	| 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |
| 304 | Not Modified	| 未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源 |
| 305 | Use Proxy | 使用代理。所请求的资源必须通过代理访问 |
| 400 | Bad Request | 客户端请求的语法错误，服务器无法理解 |
| 401 | Unauthorized | 请求要求用户的身份认证 |
| 403 | Forbidden | 服务器理解请求客户端的请求，但是拒绝执行此请求 |
| 404 | Not Found | 服务器无法根据客户端的请求找到资源（网页）|
| 405 | Method Not Allowed | 客户端请求中的方法被禁止 |
| 408 | Request Time-ou | 服务器等待客户端发送的请求时间过长，超时 |
| 500 | Internal Server Error | 服务器内部错误，无法完成请求 |
| | | 等等 |

#### HTTP Content-Type（内容类型）

| 值 | 介绍 |
| --- | --- |
| application/x-www-form-urlencoded | 这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。 |
| multipart/form-data | 这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 form 的 enctyped 等于这个值。 |
| application/json | 用来告诉服务端消息主体是序列化后的 JSON 字符串。（除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify） |
| text/xml | XML格式，它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。 |
| text/html | HTML格式 |
| text/plain | 纯文本格式 |
| image/gif	| |
| image/jpeg | |
| image/png	| |
| application/octet-stream | 二进制流数据（如常见的文件下载） |
| application/pdf | pdf格式 |

#### 对HTTP传输进行压缩

再来说下相关的前端优化的问题。

资深的前端开发人员都知道，在web开发中，对js、css、图片、font等都要进行压缩，尽可能的减小文件的大小，减少前端下载的时间，从而提高网页响应的时间。特别是在移动端，这对用户的流量还有影响。不过本文中所提的压缩并不是指这情况，而是在js，css、图片、font等资源已经压缩了的基础上（当然，这一步非必要条件，压不压缩看你心情，资源文件的压缩跟http传输过程的压缩没关系），在http传输过程中的再次压缩。

**Accept-Encoding**

在HTTP1.1开始，Web客户端可以通过Acceppt-Encoding头来标识对压缩的支持。客户端HTTP请求头声明浏览器支持的压缩方式，服务端配置启用压缩，压缩的文件类型，压缩方式。当客户端请求到达服务器，服务器响应时对请求资源进行压缩，返回给客户端浏览器，浏览器按照相应的方式进行解析。

在HTTP请求中，accept-encoding: gzip, deflate, sdch, br是指客户端浏览器（这里是我的chrome浏览器）支持的压缩方式。在HTTP响应中，content-encoding:gzip 是指服务端使用了gzip这种压缩方式。

如何使用gzip进行压缩？

客户端不用任何配置，在服务端配置即可，服务器不同，配置方法也不尽相同。

#### HTTP内容协商
在 HTTP 协议中，内容协商是这样一种机制，通过为同一 URI 指向的资源提供不同的展现形式，可以使用户代理选择与用户需求相适应的最佳匹配（例如，文档使用的自然语言，图片的格式，或者内容编码形式）

一般客户端涉及的常见头部有以下几个：
* Accept: 声明客户端可以处理的资源格式
* Accept-Charset: 声明客户端可以处理的字符集类型
* Accept-Language: 声明客户端可以理解的自然语言
* Accept-Encoding: 声明客户端支持的编码格式

而服务端涉及的常见头部包括：
* Content-Type: 指示资源的 MIME 类型
* Content-Language: 指示该资源所期望的自然语言
* Content-Encoding: 指示资源使用该编码格式进行内容转换

Vary 是一个HTTP响应头部信息，它决定了对于未来的一个请求头，应该使用一个缓存作为响应还是向源服务器请求一个新的响应。

**Vary 的工作原理**
它表示某个响应因某个响应头部而不同。举个例子，比如 Vary: Accept 的意思即为，响应因请求资源格式头部而不同，那么通过相同 URI 访问的资源就可以根据这个头上知道其内容格式不同。

**Vary 应用场景**
(1) Vary 与 动态服务

关于动态服务，最常见的莫过于 Vary: User-Agent。众所周知，UA 是一段特征字符串，通常包含区分客户端类型、操作系统、版本号等信息，随着移动 web 应用变得越流行，一个应用网站同时提供桌面和移动两种版本的应用是很常见的事情。通过设置 Vary: User-Agent 头部，对于搜索引擎，对于关键字的搜索结果可以提供更加准确的应用版本，对于客户端，可以使其从缓存服务器获取到相应应用类型的缓存版本，而不是错误地将桌面版缓存传递给移动版应用。

web 应用的性能在加载速度这一指标上，很大程度上取决于加载资源的大小，而图片资源是所占比例最大的一块。为了减少图片的大小，除了对常见的图片格式进行压缩以外，chrome 推出的 WebP 格式也是不错的选择。但是这里的问题是，不是所有的浏览器都支持 WebP 图片格式的，所以这里使用 Vary: Accept 来针对浏览器的支持情况返回相应的缓存副本，支持则返回 WebP 格式，不支持则返回缩略图或者原图。

还有其他关于动态服务的场景，比如要针对不同分辨率的屏幕加载不同质量的图片（Client Hints 相关的头部）、针对不同用户身份提供不同的资源（Cookie头部）等等。

(2) Vary 与 缓存错乱

有时候我们会发现响应中存在 Vary: Accept-Encoding 头部信息，我原先按照内容协商机制中所描述的内容来理解，但到后来才发现，其实很大程度上是为了防止缓存错乱的问题。

设想一下，如果没有这个头部，当两个分别支持 gzip 和 不支持 gzip 的客户端对同一份资源进行获取时，结果会变得十分微妙。如果不支持 gzip 的客户端先访问，缓存代理会缓存未压缩的版本，那么当支持 gzip 的客户端再访问时，由于命中缓存，虽然它支持 gzip 但也只能加载未压缩的资源。反过来同样如此，支持 gzip 客户端先访问，则缓存代理会缓存压缩版本，当不支持 gzip 的客户端再访问时，缓存同样命中，但是由于它无法对压缩资源解码，所以会呈现乱码。

通过 Vary: Accept-Encoding 我们可以防止这种情况的发生，因为 Vary 在这里其实是扮演着校验器的角色，它会进一步对命中缓存的资源进行再校验，如果发现头部信息不同，则会将缓存资源视为无效，从而将请求继续转发至源服务器。这对于缓存代理服务器也有一定的益处，因为可以有有依据地针对不同的 Accept-Encoding 缓存不同的资源副本。

(3) Vary 与 缓存命中率

Vary 虽然可以防止缓存错乱，但并不代表可以滥用，盲目的使用会适得其反，比如之前提及的 Vary: *，这样等价于将每个请求视为唯一，并且不缓存其响应资源，除非有意为之，不然没有人会牺牲缓存带来的性能提升。

同时对于一些 Header 的值是开放性的，比如之前提及的 User-Agent，如果单纯从字面量来匹配的话，众多桌面浏览器的值会因各种因素而不同的，如果仅是简单地将 UA 作为区分桌面端和移动端的依据，那么缓存命中率会达到一个很低的水平。如何解决这个问题呢？可以将这些 UA 头部的值进行标准化，比如可以通过正则匹配所有桌面浏览器的 UA 并重新更改为 Desktop，之后再转发至缓存代理和源服务器，这样有利于提高缓存命中率，关于这部分的内容，可以参考这篇文章，其中有很细致的讲解。

所以我们要时刻留意，在使用 Vary 时，一定要根据缓存命中率作出调整，在不发生缓存错乱的情况之下，尽可能的提高资源的缓存命中率。

(4)Vary 与 CORS

对于跨域的有情况，Vary 也包含一些内容。HTTP 协议规定，当服务端响应包含 Access-Control-Allow-Origin 头部，且它的值是一个具体的域名而不是通配符 *，那么这时必须要包含 Vary: Origin 这个头部。

因为请求头中的 Origin 头部代表了该请求来源的具体域名信息，那么对于不同域名网站所发起的请求，会使用仅属于它本身的缓存。一般而言，我们很少会遇到这种问题，因为一般都将 Access-Control-Allow-Origin 设置为了 *。

#### 概述http的缓存控制


#### 简述三次握手四次挥手

#### HTTPS是对称加密还是非对称加密？
HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段。

[详解](https://zhuanlan.zhihu.com/p/96494976)

